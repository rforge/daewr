for (i in 1:m){
lm<-nchar(lin[i])
cat("lm=",lm,"\n")
if(lm > 1){lg1=TRUE }
cat("lg1=",lg1,"\n")
}
cat("lg1=",lg1,"\n")
if(lg1) {stop("factor names must be of length 1")}
#make replacement table for use in getting quadratic names
values<-c("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z")
repl<-c("I(A^2)","I(B^2)","I(C^2)","I(D^2)","I(E^2)","I(F^2)","I(G^2)","I(H^2)","I(I^2)","I(J^2)","I(K^2)","I(L^2)","I(M^2)","I(N^2)","I(O^2)","I(P^2)","I(Q^2)","I(R^2)","I(S^2)","I(T^2)","I(U^2)","I(V^2)","I(W^2)","I(X^2)","I(Y^2)","I(Z^2)")
repl.tab <- cbind(values, repl)
#get quadratic variable names
if(m==0) {
quad<-character()
} else {
indx<-rep(0,m)
for (i in 1:m) {
indx[i]<-match(lin[i],repl.tab[, 1], nomatch=0)
}
quad<-rep('A',m)
for (i in 1:m) {
quad[i]<-lin[i]
}
quad[indx != 0] <- repl.tab[indx, 2]
quad<-paste(quad,collapse='+')
}
# create the data frame for analysis
dat<-data.frame(y=y,des)
#gets the model matrix
lm1<-lm(y~(.)^2,data=dat)
mm<-model.matrix(lm1)
fact<-colnames(mm)
fact<-fact[-1]
fact<-paste(fact,collapse='+')
mod<-paste(c(fact,quad),collapse='+')
#  lmtest<-lm(y~A+B+A:B+I(A^2)+I(B^2),data=dat)
lm2<-lm(reformulate(termlabels=mod, response='y'),data=dat) # This works
mm<-model.matrix(lm2)
#deletes the constant column from the model matrix
mm<-mm[,2:ncol(mm)]
# finds the initial hierarchical model with the lowest regression p-value
trm<-firstm(y,mm)
d1<-data.frame(y=y,mm[,trm])
# if only one term in the model get the correct name
if(length(trm)==1){
t1<-substr(trm,1,1)
t2<-substr(trm,2,2)
t3<-substr(trm,3,3)
iquad=FALSE
if(t2=="(") {iquad=TRUE} ### first problem here t2 has length> 1
#  }
hmt<-trm
#### second problem here t2 has length> 1
if(t2=="") {
nms<-names(d1)
nms[2]<-hmt   ## 3rd problem here number of items to replace is not a multiple of replacement length
names(d1)<-nms
}
} ## test
m1<-lm(y~(.),data=d1)
result<-summary(m1)
print(result)
return(trm)
}
firstm<-function(y,des) {
nmsm<-colnames(des)
nmt<-length(nmsm)
pval<-rep(0,nmt)
# get the pvalue for the hierarchical model associated with each term in mmsm
for (i in 1:nmt) {
term<-nmsm[i]
#checks to see if term is an interaction or quadratic term
#gets first letter in term
t1<-substr(term,1,1)
t2<-substr(term,2,2)
t3<-substr(term,3,3)
iquad=FALSE
if(t1=="I" && t2=="(") {iquad=TRUE}
hmt<-term
if(iquad){hmt<-c(term,t3)}
cmp<-FALSE
if(t2 != "" && iquad!= TRUE){cmp=TRUE}
if(cmp){hmt<-c(t1,t3,term)}
#  print(i)   was used to check
#  print(hmt)  was used to check
d2<-data.frame(y=y,des[,hmt])
m2<-lm(y~(.),data=d2)
sm2<-summary(m2)
sm2f<-sm2$fstatistic
pval[i]<-1-pf(sm2f[1],sm2f[2],sm2f[3])
#  print(pval[i])
}
# gets hierarchical model for term whose hierarchical model has the smallest pvalue
idx<-which.min(pval)
term<-nmsm[idx]
#checks to see if term is an interaction or quadratic term
#gets first letter in term
t1<-substr(term,1,1)
t2<-substr(term,2,2)
t3<-substr(term,3,3)
iquad=FALSE
if(t1=="I"&& t2=="(") {iquad=TRUE}
mt<-term
if(iquad){mt<-c(term,t3)}
cmp<-FALSE
if(t2!= ""&& iquad!=TRUE){cmp=TRUE}
if(cmp){mt<-c(t1,t3,term)}
return(mt)
}
trm<-ihstep(x$y,x[ ,-6],m=5,c=0)
# Example p. 240 Design and Analysis of Experiments with R PB Design
library(BsMD)
data(PB12Des,package="BsMD")
colnames(PB12Des)<-c("c11","c10","c9","c8","G","F","E","D","C","B","A")
#Reorder the columns to match Table 6.11
castf<-PB12Des[c(11,10,9,8,7,6,5,4,3,2,1)]
y<-c(4.733,4.625,5.899,7.0,5.752,5.682,6.607,5.818,5.917,5.863,6.058,4.809)
castf<-cbind(castf,y)
castfr <- castf[ , c(1:7, 12)]
# Example p. 240 Design and Analysis of Experiments with R PB Design
library(BsMD)
data(PB12Des,package="BsMD")
colnames(PB12Des)<-c("c11","c10","c9","c8","G","F","E","D","C","B","A")
#Reorder the columns to match Table 6.11
castf<-PB12Des[c(11,10,9,8,7,6,5,4,3,2,1)]
y<-c(4.733,4.625,5.899,7.0,5.752,5.682,6.607,5.818,5.917,5.863,6.058,4.809)
castf<-cbind(castf,y)
castfr <- castf[ , c(1:7, 12)]
des<-castfr[ ,c(1:7)]
y<-castfr[ , 8]
des
y
trm<-ihstep((y,des,m=0,c=7)
ihstep <- function(y,des,m,c) {
#get names of linear terms
lin<-colnames(des)
#  print(lin)
lg1=FALSE
for (i in 1:m){
lm<-nchar(lin[i])
#    cat("lm=",lm,"\n")
if(lm > 1){lg1=TRUE }
#    cat("lg1=",lg1,"\n")
}
#  cat("lg1=",lg1,"\n")
if(lg1) {stop("factor names must be of length 1")}
#make replacement table for use in getting quadratic names
values<-c("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z")
repl<-c("I(A^2)","I(B^2)","I(C^2)","I(D^2)","I(E^2)","I(F^2)","I(G^2)","I(H^2)","I(I^2)","I(J^2)","I(K^2)","I(L^2)","I(M^2)","I(N^2)","I(O^2)","I(P^2)","I(Q^2)","I(R^2)","I(S^2)","I(T^2)","I(U^2)","I(V^2)","I(W^2)","I(X^2)","I(Y^2)","I(Z^2)")
repl.tab <- cbind(values, repl)
#get quadratic variable names
if(m==0) {
quad<-character()
} else {
indx<-rep(0,m)
for (i in 1:m) {
indx[i]<-match(lin[i],repl.tab[, 1], nomatch=0)
}
quad<-rep('A',m)
for (i in 1:m) {
quad[i]<-lin[i]
}
quad[indx != 0] <- repl.tab[indx, 2]
quad<-paste(quad,collapse='+')
}
# create the data frame for analysis
dat<-data.frame(y=y,des)
#gets the model matrix
lm1<-lm(y~(.)^2,data=dat)
mm<-model.matrix(lm1)
fact<-colnames(mm)
fact<-fact[-1]
fact<-paste(fact,collapse='+')
mod<-paste(c(fact,quad),collapse='+')
#  lmtest<-lm(y~A+B+A:B+I(A^2)+I(B^2),data=dat)
lm2<-lm(reformulate(termlabels=mod, response='y'),data=dat) # This works
mm<-model.matrix(lm2)
#deletes the constant column from the model matrix
mm<-mm[,2:ncol(mm)]
# finds the initial hierarchical model with the lowest regression p-value
trm<-firstm(y,mm)
d1<-data.frame(y=y,mm[,trm])
# if only one term in the model get the correct name
if(length(trm)==1){
t1<-substr(trm,1,1)
t2<-substr(trm,2,2)
t3<-substr(trm,3,3)
iquad=FALSE
if(t2=="(") {iquad=TRUE} ### first problem here t2 has length> 1
#  }
hmt<-trm
#### second problem here t2 has length> 1
if(t2=="") {
nms<-names(d1)
nms[2]<-hmt   ## 3rd problem here number of items to replace is not a multiple of replacement length
names(d1)<-nms
}
} ## test
m1<-lm(y~(.),data=d1)
result<-summary(m1)
print(result)
return(trm)
}
firstm<-function(y,des) {
nmsm<-colnames(des)
nmt<-length(nmsm)
pval<-rep(0,nmt)
# get the pvalue for the hierarchical model associated with each term in mmsm
for (i in 1:nmt) {
term<-nmsm[i]
#checks to see if term is an interaction or quadratic term
#gets first letter in term
t1<-substr(term,1,1)
t2<-substr(term,2,2)
t3<-substr(term,3,3)
iquad=FALSE
if(t1=="I" && t2=="(") {iquad=TRUE}
hmt<-term
if(iquad){hmt<-c(term,t3)}
cmp<-FALSE
if(t2 != "" && iquad!= TRUE){cmp=TRUE}
if(cmp){hmt<-c(t1,t3,term)}
#  print(i)   was used to check
#  print(hmt)  was used to check
d2<-data.frame(y=y,des[,hmt])
m2<-lm(y~(.),data=d2)
sm2<-summary(m2)
sm2f<-sm2$fstatistic
pval[i]<-1-pf(sm2f[1],sm2f[2],sm2f[3])
#  print(pval[i])
}
# gets hierarchical model for term whose hierarchical model has the smallest pvalue
idx<-which.min(pval)
term<-nmsm[idx]
#checks to see if term is an interaction or quadratic term
#gets first letter in term
t1<-substr(term,1,1)
t2<-substr(term,2,2)
t3<-substr(term,3,3)
iquad=FALSE
if(t1=="I"&& t2=="(") {iquad=TRUE}
mt<-term
if(iquad){mt<-c(term,t3)}
cmp<-FALSE
if(t2!= ""&& iquad!=TRUE){cmp=TRUE}
if(cmp){mt<-c(t1,t3,term)}
return(mt)
}
trm<-ihstep(y,des,m=0,c=7)
ihstep <- function(y,des,m,c) {
#get names of linear terms
lin<-colnames(des)
print(lin)
lg1=FALSE
for (i in 1:m){
lm<-nchar(lin[i])
cat("lm=",lm,"\n")
if(lm > 1){lg1=TRUE }
cat("lg1=",lg1,"\n")
}
cat("lg1=",lg1,"\n")
if(lg1) {stop("factor names must be of length 1")}
#make replacement table for use in getting quadratic names
values<-c("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z")
repl<-c("I(A^2)","I(B^2)","I(C^2)","I(D^2)","I(E^2)","I(F^2)","I(G^2)","I(H^2)","I(I^2)","I(J^2)","I(K^2)","I(L^2)","I(M^2)","I(N^2)","I(O^2)","I(P^2)","I(Q^2)","I(R^2)","I(S^2)","I(T^2)","I(U^2)","I(V^2)","I(W^2)","I(X^2)","I(Y^2)","I(Z^2)")
repl.tab <- cbind(values, repl)
#get quadratic variable names
if(m==0) {
quad<-character()
} else {
indx<-rep(0,m)
for (i in 1:m) {
indx[i]<-match(lin[i],repl.tab[, 1], nomatch=0)
}
quad<-rep('A',m)
for (i in 1:m) {
quad[i]<-lin[i]
}
quad[indx != 0] <- repl.tab[indx, 2]
quad<-paste(quad,collapse='+')
}
# create the data frame for analysis
dat<-data.frame(y=y,des)
#gets the model matrix
lm1<-lm(y~(.)^2,data=dat)
mm<-model.matrix(lm1)
fact<-colnames(mm)
fact<-fact[-1]
fact<-paste(fact,collapse='+')
mod<-paste(c(fact,quad),collapse='+')
#  lmtest<-lm(y~A+B+A:B+I(A^2)+I(B^2),data=dat)
lm2<-lm(reformulate(termlabels=mod, response='y'),data=dat) # This works
mm<-model.matrix(lm2)
#deletes the constant column from the model matrix
mm<-mm[,2:ncol(mm)]
# finds the initial hierarchical model with the lowest regression p-value
trm<-firstm(y,mm)
d1<-data.frame(y=y,mm[,trm])
# if only one term in the model get the correct name
if(length(trm)==1){
t1<-substr(trm,1,1)
t2<-substr(trm,2,2)
t3<-substr(trm,3,3)
iquad=FALSE
if(t2=="(") {iquad=TRUE} ### first problem here t2 has length> 1
#  }
hmt<-trm
#### second problem here t2 has length> 1
if(t2=="") {
nms<-names(d1)
nms[2]<-hmt   ## 3rd problem here number of items to replace is not a multiple of replacement length
names(d1)<-nms
}
} ## test
m1<-lm(y~(.),data=d1)
result<-summary(m1)
print(result)
return(trm)
}
y
des
trm<-ihstep(y,des,m=0,c=7)
y
des
m
m<-7
lg1=FALSE
cat("m=",m)
for (i in 1:m){
lm<-nchar(lin[i])
cat("lm=",lm,"\n")
if(lm > 1){lg1=TRUE }
cat("lg1=",lg1,"\n")
}
lin
des
lin<-colnames(des)
print(lin)
lg1=FALSE
cat("m=",m)
for (i in 1:m){
lm<-nchar(lin[i])
cat("lm=",lm,"\n")
if(lm > 1){lg1=TRUE }
cat("lg1=",lg1,"\n")
}
cat("lg1=",lg1,"\n")
y
des
ihstep <- function(y,des,m,c) {
#get names of linear terms
lin<-colnames(des)
print(lin)
lg1=FALSE
cat("m=",m)
cat("c=",c)
for (i in 1:m+c){
lm<-nchar(lin[i])
cat("lm=",lm,"\n")
if(lm > 1){lg1=TRUE }
cat("lg1=",lg1,"\n")
}
cat("lg1=",lg1,"\n")
if(lg1) {stop("factor names must be of length 1")}
#make replacement table for use in getting quadratic names
values<-c("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z")
repl<-c("I(A^2)","I(B^2)","I(C^2)","I(D^2)","I(E^2)","I(F^2)","I(G^2)","I(H^2)","I(I^2)","I(J^2)","I(K^2)","I(L^2)","I(M^2)","I(N^2)","I(O^2)","I(P^2)","I(Q^2)","I(R^2)","I(S^2)","I(T^2)","I(U^2)","I(V^2)","I(W^2)","I(X^2)","I(Y^2)","I(Z^2)")
repl.tab <- cbind(values, repl)
#get quadratic variable names
if(m==0) {
quad<-character()
} else {
indx<-rep(0,m)
for (i in 1:m) {
indx[i]<-match(lin[i],repl.tab[, 1], nomatch=0)
}
quad<-rep('A',m)
for (i in 1:m) {
quad[i]<-lin[i]
}
quad[indx != 0] <- repl.tab[indx, 2]
quad<-paste(quad,collapse='+')
}
# create the data frame for analysis
dat<-data.frame(y=y,des)
#gets the model matrix
lm1<-lm(y~(.)^2,data=dat)
mm<-model.matrix(lm1)
fact<-colnames(mm)
fact<-fact[-1]
fact<-paste(fact,collapse='+')
mod<-paste(c(fact,quad),collapse='+')
#  lmtest<-lm(y~A+B+A:B+I(A^2)+I(B^2),data=dat)
lm2<-lm(reformulate(termlabels=mod, response='y'),data=dat) # This works
mm<-model.matrix(lm2)
#deletes the constant column from the model matrix
mm<-mm[,2:ncol(mm)]
# finds the initial hierarchical model with the lowest regression p-value
trm<-firstm(y,mm)
d1<-data.frame(y=y,mm[,trm])
# if only one term in the model get the correct name
if(length(trm)==1){
t1<-substr(trm,1,1)
t2<-substr(trm,2,2)
t3<-substr(trm,3,3)
iquad=FALSE
if(t2=="(") {iquad=TRUE} ### first problem here t2 has length> 1
#  }
hmt<-trm
#### second problem here t2 has length> 1
if(t2=="") {
nms<-names(d1)
nms[2]<-hmt   ## 3rd problem here number of items to replace is not a multiple of replacement length
names(d1)<-nms
}
} ## test
m1<-lm(y~(.),data=d1)
result<-summary(m1)
print(result)
return(trm)
}
# Example p. 240 Design and Analysis of Experiments with R PB Design
library(BsMD)
data(PB12Des,package="BsMD")
colnames(PB12Des)<-c("c11","c10","c9","c8","G","F","E","D","C","B","A")
#Reorder the columns to match Table 6.11
castf<-PB12Des[c(11,10,9,8,7,6,5,4,3,2,1)]
y<-c(4.733,4.625,5.899,7.0,5.752,5.682,6.607,5.818,5.917,5.863,6.058,4.809)
castf<-cbind(castf,y)
castfr <- castf[ , c(1:7, 12)]
des<-castfr[ ,c(1:7)]
y<-castfr[ , 8]
library(daewr)
trm<-ihstep(y,des,m=0,c=7)
m+c
ihstep <- function(y,des,m,c) {
#get names of linear terms
lin<-colnames(des)
print(lin)
lg1=FALSE
cat("m=",m,"\n")
cat("c=",c,"\n")
mc<-m+c
for (i in 1:mc){
lm<-nchar(lin[i])
cat("lm=",lm,"\n")
if(lm > 1){lg1=TRUE }
cat("lg1=",lg1,"\n")
}
cat("lg1=",lg1,"\n")
if(lg1) {stop("factor names must be of length 1")}
#make replacement table for use in getting quadratic names
values<-c("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z")
repl<-c("I(A^2)","I(B^2)","I(C^2)","I(D^2)","I(E^2)","I(F^2)","I(G^2)","I(H^2)","I(I^2)","I(J^2)","I(K^2)","I(L^2)","I(M^2)","I(N^2)","I(O^2)","I(P^2)","I(Q^2)","I(R^2)","I(S^2)","I(T^2)","I(U^2)","I(V^2)","I(W^2)","I(X^2)","I(Y^2)","I(Z^2)")
repl.tab <- cbind(values, repl)
#get quadratic variable names
if(m==0) {
quad<-character()
} else {
indx<-rep(0,m)
for (i in 1:m) {
indx[i]<-match(lin[i],repl.tab[, 1], nomatch=0)
}
quad<-rep('A',m)
for (i in 1:m) {
quad[i]<-lin[i]
}
quad[indx != 0] <- repl.tab[indx, 2]
quad<-paste(quad,collapse='+')
}
# create the data frame for analysis
dat<-data.frame(y=y,des)
#gets the model matrix
lm1<-lm(y~(.)^2,data=dat)
mm<-model.matrix(lm1)
fact<-colnames(mm)
fact<-fact[-1]
fact<-paste(fact,collapse='+')
mod<-paste(c(fact,quad),collapse='+')
#  lmtest<-lm(y~A+B+A:B+I(A^2)+I(B^2),data=dat)
lm2<-lm(reformulate(termlabels=mod, response='y'),data=dat) # This works
mm<-model.matrix(lm2)
#deletes the constant column from the model matrix
mm<-mm[,2:ncol(mm)]
# finds the initial hierarchical model with the lowest regression p-value
trm<-firstm(y,mm)
d1<-data.frame(y=y,mm[,trm])
# if only one term in the model get the correct name
if(length(trm)==1){
t1<-substr(trm,1,1)
t2<-substr(trm,2,2)
t3<-substr(trm,3,3)
iquad=FALSE
if(t2=="(") {iquad=TRUE} ### first problem here t2 has length> 1
#  }
hmt<-trm
#### second problem here t2 has length> 1
if(t2=="") {
nms<-names(d1)
nms[2]<-hmt   ## 3rd problem here number of items to replace is not a multiple of replacement length
names(d1)<-nms
}
} ## test
m1<-lm(y~(.),data=d1)
result<-summary(m1)
print(result)
return(trm)
}
y
des
trm<-ihstep(y,des,m=0,c=7)
